import fs from "fs";
import path from "path";
import {
  ClassDeclaration,
  EnumDeclaration,
  FunctionDeclaration,
  InterfaceDeclaration,
  Project,
  PropertyDeclaration,
  Type,
  TypeAliasDeclaration,
  VariableDeclaration,
} from "ts-morph";

class TypeInfo {
  private maxDepth: number;

  private project: Project;

  constructor(maxDepth: number) {
    this.maxDepth = maxDepth;
    this.project = new Project();
  }

  public describe(identifier: string, filePath: string): string {
    const sourceFile = this.project.addSourceFileAtPath(filePath);

    const classDeclaration = sourceFile.getClass(identifier);
    if (classDeclaration) {
      return this.describeClass(classDeclaration, 0);
    }

    const interfaceDeclaration = sourceFile.getInterface(identifier);
    if (interfaceDeclaration) {
      return this.describeInterface(interfaceDeclaration, 0);
    }

    const typeAlias = sourceFile.getTypeAlias(identifier);
    if (typeAlias) {
      return this.describeTypeAlias(typeAlias, 0);
    }

    const variable = sourceFile.getVariableDeclaration(identifier);
    if (variable) {
      return this.describeVariable(variable, 0);
    }

    const functionDeclaration = sourceFile.getFunction(identifier);
    if (functionDeclaration) {
      return this.describeFunction(functionDeclaration, 0);
    }

    const enumDeclaration = sourceFile.getEnum(identifier);
    if (enumDeclaration) {
      return this.describeEnum(enumDeclaration, 0);
    }

    throw new Error(`Identifier ${identifier} not found in ${filePath}`);
  }

  private describeVariable(
    variable: VariableDeclaration,
    depth: number
  ): string {
    if (depth > this.maxDepth) {
      return "";
    }
    const indent = "  ".repeat(depth);
    return `${indent}const ${variable.getName()}: ${this.describeType(
      variable.getType(),
      depth + 1
    )}`;
  }

  private describeFunction(
    functionDeclaration: FunctionDeclaration,
    depth: number
  ): string {
    if (depth > this.maxDepth) {
      return "";
    }
    const indent = "  ".repeat(depth);
    return `${indent}function ${functionDeclaration.getName()}(${functionDeclaration
      .getParameters()
      .map(
        /**
         * Generates a string representation of a parameter's name and its type.
         * @param {Object} param - An object representing the parameter, which includes methods to get the name and type.
         * @returns {string} A formatted string combining the parameter's name and type description.
         */
        (param) =>
          `${param.getName()}: ${this.describeType(param.getType(), depth + 1)}`
      )
      .join(", ")}): ${this.describeType(
      functionDeclaration.getReturnType(),
      depth + 1
    )}`;
  }

  private describeClass(
    classDeclaration: ClassDeclaration,
    depth: number
  ): string {
    if (depth > this.maxDepth) {
      return "";
    }
    const indent = "  ".repeat(depth);
    return `${indent}class ${classDeclaration.getName()} {
${classDeclaration
  .getProperties()
  /**
   * Maps over a collection of properties and describes each property recursively.
   * @param {Object} property - The property object to be described.
   * @returns {Array} An array containing the descriptions of each property, generated by the describeProperty method.
   */
  .map((property) => this.describeProperty(property, depth + 1))
  .join("\n")}
${classDeclaration
  .getMethods()
  /**
   * Iterates over an array of methods and generates a detailed description 
   * for each function declaration at the specified depth.
   * @param {FunctionDeclaration} method - A method to be described.
   * @returns {DescriptionType} An array of descriptions for each method.
   */
  .map((method) =>
    this.describeFunction(method as unknown as FunctionDeclaration, depth + 1)
  )
  .join("\n")}
${indent}}`;
  }

  private describeProperty(
    property: PropertyDeclaration,
    depth: number
  ): string {
    const indent = "  ".repeat(depth);
    return `${indent}  ${property.getName()}: ${this.describeType(
      property.getType(),
      depth + 1
    )}`;
  }

  private describeInterface(
    interfaceDeclaration: InterfaceDeclaration,
    depth: number
  ): string {
    if (depth > this.maxDepth) {
      return "";
    }
    const indent = "  ".repeat(depth);
    return `${indent}interface ${interfaceDeclaration.getName()} {
${interfaceDeclaration
  .getProperties()
  /**
   * Maps over an array of properties and describes each property using the describeProperty method.
   * @param {PropertyDeclaration} property - The property to be described, cast to PropertyDeclaration type.
   * @returns {Description} A detailed description of the property.
   */
  .map((property) =>
    this.describeProperty(property as unknown as PropertyDeclaration, depth + 1)
  )
  .join("\n")}
${interfaceDeclaration
  .getMethods()
  /**
   * Transforms an array of methods by describing each function using the describeFunction method.
   * @param {FunctionDeclaration} method - The method to be described.
   * @returns {Array} An array of descriptions for each method.
   */
  .map((method) =>
    this.describeFunction(method as unknown as FunctionDeclaration, depth + 1)
  )
  .join("\n")}
${indent}}`;
  }

  private describeTypeAlias(
    typeAlias: TypeAliasDeclaration,
    depth: number
  ): string {
    if (depth > this.maxDepth) {
      return "";
    }
    const indent = "  ".repeat(depth);
    return `${indent}type ${typeAlias.getName()} = ${this.describeType(
      typeAlias.getType(),
      depth + 1
    )}`;
  }

  private describeEnum(
    enumDeclaration: EnumDeclaration,
    depth: number
  ): string {
    if (depth > this.maxDepth) {
      return "";
    }
    const indent = "  ".repeat(depth);
    return `${indent}enum ${enumDeclaration.getName()} {
${enumDeclaration
  .getMembers()
  /**
   * Transforms an array of member objects into a formatted string representation.
   * Each member string is prefixed with an indentation and includes the member's name and value.
   * @param {Array} members - An array of member objects containing `getName` and `getValue` methods.
   * @returns {Array} An array of formatted strings representing each member.
   */
  .map((member) => `${indent}  ${member.getName()} = ${member.getValue()}`)
  .join(",\n")}
${indent}}`;
  }

  private describeType(type: Type, depth: number): string {
    if (depth > this.maxDepth) {
      return "...";
    }
    const indent = "  ".repeat(depth);

    if (type.isUnion()) {
      return type
        .getUnionTypes()
        /**
         * Transforms an array of types by providing a detailed description of each type at a specified depth.
         * @param {Array}  t - An array of types to be described.
         * @param {number} depth - The depth level used in the description of types.
         * @returns {Array} An array containing the descriptions of the types at the given depth.
         */
        .map((t) => this.describeType(t, depth))
        .join(" | ");
    }

    if (type.isIntersection()) {
      return type
        .getIntersectionTypes()
        /**
         * Transforms an array of input values by applying the describeType method to each element.
         * @param {Array} t - An array of values to be transformed.
         * @returns {Array} A new array containing the results of describeType applied to each element in the input array.
         */
        .map((t) => this.describeType(t, depth))
        .join(" & ");
    }

    if (type.isArray()) {
      return `${this.describeType(type.getArrayElementType()!, depth)}[]`;
    }

    if (type.isObject() && !type.isInterface()) {
      const properties = type.getProperties();
      if (properties.length === 0) {
        return "{}";
      }
      return `{
${properties
  /**
   * Maps over a collection of properties, retrieving their names and types,
   * and formats them into a string representation.
   * @param {Object} prop - The property object containing metadata.
   * @returns {string} A formatted string representing the property name and type.
   */
  .map((prop) => {
    const valueDeclaration = prop.getValueDeclaration();
    if (!valueDeclaration) {
      return `${indent}  ${prop.getName()}: unknown`;
    }
    return `${indent}  ${prop.getName()}: ${this.describeType(
      prop.getTypeAtLocation(valueDeclaration),
      depth + 1
    )}`;
  })
  .join(",\n")}
${indent}}`;
    }

    return type.getText();
  }
}

/**
 * Retrieves the type descriptor for a given identifier in a specified file.
 * @param {string}  identifier - The name of the identifier whose type description is to be retrieved.
 * @param {string}  filePath - The path to the file where the identifier is defined.
 * @param {number}  maxDepth - The maximum depth of type resolution to be performed.
 * @returns {string} A string describing the type of the identifier.
 */
function getTypeDescriptor(
  identifier: string,
  filePath: string,
  maxDepth: number
): string {
  return new TypeInfo(maxDepth).describe(identifier, filePath);
}

/**
 * Main function to execute the script, parse command line arguments,
 * retrieve type information for a specified identifier from a file,
 * and write the output to a temporary declaration file.
 * @param {void}  No parameters are required for this function.
 * @returns {void} This function does not return a value.
 */
function main() {
  const args = process.argv.slice(2);
  let maxDepth = 5;
  let filePath, identifier;

  for (let i = 0; i < args.length; i++) {
    if (args[i].startsWith("--max-depth=")) {
      maxDepth = parseInt(args[i].split("=")[1], 10);
      if (isNaN(maxDepth)) {
        console.error("Invalid max depth value");
        process.exit(1);
      }
    } else if (!filePath) {
      filePath = args[i];
    } else if (!identifier) {
      identifier = args[i];
    }
  }

  if (!filePath || !identifier) {
    console.error(
      "Usage: node script.js <file_path> <identifier> [--max-depth=<number>]"
    );
    process.exit(1);
  }

  console.log(
    "Getting type info for",
    identifier,
    "in",
    filePath,
    "with max depth",
    maxDepth
  );
  const typeString = getTypeDescriptor(identifier, filePath, maxDepth);

  const outputPath = path.join(process.cwd(), "temp_output_declaration.txt");

  try {
    fs.writeFileSync(outputPath, typeString, "utf8");
    console.log(`Type information has been written to ${outputPath}`);
  } catch (error) {
    console.error(`Error writing to file: ${error}`);
  }
}

main();
